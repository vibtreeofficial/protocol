// Code generated by protoc-gen-psrpc v0.6.0, DO NOT EDIT.
// source: rpc/signal.proto

package rpc

import (
	"context"

	"github.com/vibtreeofficial/psrpc"
	"github.com/vibtreeofficial/psrpc/pkg/client"
	"github.com/vibtreeofficial/psrpc/pkg/info"
	"github.com/vibtreeofficial/psrpc/pkg/rand"
	"github.com/vibtreeofficial/psrpc/pkg/server"
	"github.com/vibtreeofficial/psrpc/version"
)

var _ = version.PsrpcVersion_0_6

// =======================
// Signal Client Interface
// =======================

type SignalClient[NodeIdTopicType ~string] interface {
	RelaySignal(ctx context.Context, nodeId NodeIdTopicType, opts ...psrpc.RequestOption) (psrpc.ClientStream[*RelaySignalRequest, *RelaySignalResponse], error)

	// Close immediately, without waiting for pending RPCs
	Close()
}

// ===========================
// Signal ServerImpl Interface
// ===========================

type SignalServerImpl interface {
	RelaySignal(psrpc.ServerStream[*RelaySignalResponse, *RelaySignalRequest]) error
}

// =======================
// Signal Server Interface
// =======================

type SignalServer[NodeIdTopicType ~string] interface {
	RegisterRelaySignalTopic(nodeId NodeIdTopicType) error
	DeregisterRelaySignalTopic(nodeId NodeIdTopicType)
	RegisterAllNodeTopics(nodeId NodeIdTopicType) error
	DeregisterAllNodeTopics(nodeId NodeIdTopicType)

	// Close and wait for pending RPCs to complete
	Shutdown()

	// Close immediately, without waiting for pending RPCs
	Kill()
}

// =============
// Signal Client
// =============

type signalClient[NodeIdTopicType ~string] struct {
	client *client.RPCClient
}

// NewSignalClient creates a psrpc client that implements the SignalClient interface.
func NewSignalClient[NodeIdTopicType ~string](bus psrpc.MessageBus, opts ...psrpc.ClientOption) (SignalClient[NodeIdTopicType], error) {
	sd := &info.ServiceDefinition{
		Name: "Signal",
		ID:   rand.NewClientID(),
	}

	sd.RegisterMethod("RelaySignal", false, false, false, true)

	rpcClient, err := client.NewRPCClientWithStreams(sd, bus, opts...)
	if err != nil {
		return nil, err
	}

	return &signalClient[NodeIdTopicType]{
		client: rpcClient,
	}, nil
}

func (c *signalClient[NodeIdTopicType]) RelaySignal(ctx context.Context, nodeId NodeIdTopicType, opts ...psrpc.RequestOption) (psrpc.ClientStream[*RelaySignalRequest, *RelaySignalResponse], error) {
	return client.OpenStream[*RelaySignalRequest, *RelaySignalResponse](ctx, c.client, "RelaySignal", []string{string(nodeId)}, opts...)
}

func (s *signalClient[NodeIdTopicType]) Close() {
	s.client.Close()
}

// =============
// Signal Server
// =============

type signalServer[NodeIdTopicType ~string] struct {
	svc SignalServerImpl
	rpc *server.RPCServer
}

// NewSignalServer builds a RPCServer that will route requests
// to the corresponding method in the provided svc implementation.
func NewSignalServer[NodeIdTopicType ~string](svc SignalServerImpl, bus psrpc.MessageBus, opts ...psrpc.ServerOption) (SignalServer[NodeIdTopicType], error) {
	sd := &info.ServiceDefinition{
		Name: "Signal",
		ID:   rand.NewServerID(),
	}

	s := server.NewRPCServer(sd, bus, opts...)

	sd.RegisterMethod("RelaySignal", false, false, false, true)
	return &signalServer[NodeIdTopicType]{
		svc: svc,
		rpc: s,
	}, nil
}

func (s *signalServer[NodeIdTopicType]) RegisterRelaySignalTopic(nodeId NodeIdTopicType) error {
	return server.RegisterStreamHandler(s.rpc, "RelaySignal", []string{string(nodeId)}, s.svc.RelaySignal, nil)
}

func (s *signalServer[NodeIdTopicType]) DeregisterRelaySignalTopic(nodeId NodeIdTopicType) {
	s.rpc.DeregisterHandler("RelaySignal", []string{string(nodeId)})
}

func (s *signalServer[NodeIdTopicType]) allNodeTopicRegisterers() server.RegistererSlice {
	return server.RegistererSlice{
		server.NewRegisterer(s.RegisterRelaySignalTopic, s.DeregisterRelaySignalTopic),
	}
}

func (s *signalServer[NodeIdTopicType]) RegisterAllNodeTopics(nodeId NodeIdTopicType) error {
	return s.allNodeTopicRegisterers().Register(nodeId)
}

func (s *signalServer[NodeIdTopicType]) DeregisterAllNodeTopics(nodeId NodeIdTopicType) {
	s.allNodeTopicRegisterers().Deregister(nodeId)
}

func (s *signalServer[NodeIdTopicType]) Shutdown() {
	s.rpc.Close(false)
}

func (s *signalServer[NodeIdTopicType]) Kill() {
	s.rpc.Close(true)
}

var psrpcFileDescriptor9 = []byte{
	// 327 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x91, 0xcf, 0x4e, 0xc2, 0x40,
	0x10, 0xc6, 0xb3, 0xb6, 0x20, 0x2e, 0x92, 0x90, 0xc5, 0x68, 0x2d, 0x9a, 0x34, 0x5c, 0xac, 0x97,
	0x36, 0xc1, 0x83, 0x89, 0x17, 0x13, 0x1f, 0x61, 0xb9, 0x79, 0x69, 0xca, 0xb2, 0xe0, 0x26, 0xa5,
	0xbb, 0xcc, 0x6c, 0x4d, 0x78, 0x04, 0x5f, 0xc7, 0x83, 0xcf, 0x67, 0xda, 0x55, 0x2c, 0xc2, 0x65,
	0x33, 0x7f, 0xbe, 0xf9, 0x7e, 0x93, 0x59, 0x3a, 0x04, 0x23, 0x52, 0x54, 0xab, 0x32, 0x2f, 0x12,
	0x03, 0xda, 0x6a, 0xe6, 0x81, 0x11, 0xe1, 0x40, 0x1b, 0xab, 0x74, 0x89, 0xae, 0x16, 0x8e, 0xd7,
	0x72, 0xa1, 0xf2, 0x0c, 0x74, 0x65, 0x25, 0x64, 0xaa, 0xb4, 0x12, 0x76, 0x03, 0xe1, 0xe5, 0x5e,
	0x13, 0xac, 0x70, 0xf5, 0xc9, 0x17, 0xa1, 0x8c, 0xcb, 0x22, 0xdf, 0xce, 0x1a, 0x7b, 0x2e, 0x37,
	0x95, 0x44, 0xcb, 0x9e, 0xe9, 0x00, 0x6d, 0x0e, 0x36, 0x43, 0x89, 0xa8, 0x74, 0x19, 0x90, 0x88,
	0xc4, 0xfd, 0x69, 0x98, 0xb4, 0x6d, 0x92, 0x59, 0x2d, 0x99, 0x39, 0x05, 0x3f, 0xc7, 0x56, 0xc6,
	0x1e, 0x69, 0x0f, 0x9c, 0x17, 0x06, 0x5e, 0xe4, 0xc5, 0xfd, 0xe9, 0xf8, 0xdf, 0x6c, 0x9b, 0xc7,
	0x77, 0x62, 0x36, 0xa4, 0x1e, 0xca, 0x4d, 0xe0, 0x47, 0x24, 0xf6, 0x79, 0x1d, 0xb2, 0x0b, 0xda,
	0x11, 0x85, 0x46, 0x19, 0x74, 0x22, 0x12, 0xf7, 0xb8, 0x4b, 0x26, 0x5b, 0x3a, 0xda, 0xdb, 0x1b,
	0x8d, 0x2e, 0x51, 0xb2, 0x27, 0x7a, 0x06, 0x3f, 0x31, 0x06, 0x27, 0x0d, 0xf8, 0xe6, 0x38, 0xd8,
	0x89, 0xf8, 0x9f, 0xfc, 0x17, 0xed, 0x1d, 0x41, 0xfb, 0x2d, 0xf4, 0x54, 0xd1, 0xae, 0x33, 0x61,
	0x19, 0xed, 0xb7, 0x96, 0x60, 0x57, 0x09, 0x18, 0x91, 0x1c, 0x9e, 0x33, 0x0c, 0x0e, 0x1b, 0x0e,
	0x3a, 0xb9, 0xfd, 0xfc, 0x20, 0xd7, 0x43, 0x12, 0x8e, 0xa8, 0x5f, 0xea, 0x85, 0x64, 0xa7, 0xf5,
	0x9b, 0xa9, 0x45, 0x7d, 0xf0, 0x88, 0xbc, 0xdc, 0xbf, 0xde, 0xad, 0x94, 0x7d, 0xab, 0xe6, 0x89,
	0xd0, 0xeb, 0xf4, 0x5d, 0xcd, 0x2d, 0x48, 0xa9, 0x97, 0x4b, 0x25, 0x54, 0x5e, 0xa4, 0xcd, 0x17,
	0x0a, 0x5d, 0xa4, 0x60, 0xc4, 0xbc, 0xdb, 0x64, 0x0f, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x91,
	0xf2, 0x87, 0xe0, 0x2d, 0x02, 0x00, 0x00,
}
