// Code generated by protoc-gen-psrpc v0.6.0, DO NOT EDIT.
// source: rpc/roommanager.proto

package rpc

import (
	"context"

	"github.com/vibtreeofficial/psrpc"
	"github.com/vibtreeofficial/psrpc/pkg/client"
	"github.com/vibtreeofficial/psrpc/pkg/info"
	"github.com/vibtreeofficial/psrpc/pkg/rand"
	"github.com/vibtreeofficial/psrpc/pkg/server"
	"github.com/vibtreeofficial/psrpc/version"
)
import media_router1 "github.com/vibtreeofficial/protocol/media-router"
import media_router6 "github.com/vibtreeofficial/protocol/media-router"

var _ = version.PsrpcVersion_0_6

// ============================
// RoomManager Client Interface
// ============================

type RoomManagerClient[NodeIdTopicType ~string] interface {
	CreateRoom(ctx context.Context, nodeId NodeIdTopicType, req *media_router6.CreateRoomRequest, opts ...psrpc.RequestOption) (*media_router1.Room, error)

	// Close immediately, without waiting for pending RPCs
	Close()
}

// ================================
// RoomManager ServerImpl Interface
// ================================

type RoomManagerServerImpl interface {
	CreateRoom(context.Context, *media_router6.CreateRoomRequest) (*media_router1.Room, error)
}

// ============================
// RoomManager Server Interface
// ============================

type RoomManagerServer[NodeIdTopicType ~string] interface {
	RegisterCreateRoomTopic(nodeId NodeIdTopicType) error
	DeregisterCreateRoomTopic(nodeId NodeIdTopicType)
	RegisterAllNodeTopics(nodeId NodeIdTopicType) error
	DeregisterAllNodeTopics(nodeId NodeIdTopicType)

	// Close and wait for pending RPCs to complete
	Shutdown()

	// Close immediately, without waiting for pending RPCs
	Kill()
}

// ==================
// RoomManager Client
// ==================

type roomManagerClient[NodeIdTopicType ~string] struct {
	client *client.RPCClient
}

// NewRoomManagerClient creates a psrpc client that implements the RoomManagerClient interface.
func NewRoomManagerClient[NodeIdTopicType ~string](bus psrpc.MessageBus, opts ...psrpc.ClientOption) (RoomManagerClient[NodeIdTopicType], error) {
	sd := &info.ServiceDefinition{
		Name: "RoomManager",
		ID:   rand.NewClientID(),
	}

	sd.RegisterMethod("CreateRoom", false, false, true, true)

	rpcClient, err := client.NewRPCClient(sd, bus, opts...)
	if err != nil {
		return nil, err
	}

	return &roomManagerClient[NodeIdTopicType]{
		client: rpcClient,
	}, nil
}

func (c *roomManagerClient[NodeIdTopicType]) CreateRoom(ctx context.Context, nodeId NodeIdTopicType, req *media_router6.CreateRoomRequest, opts ...psrpc.RequestOption) (*media_router1.Room, error) {
	return client.RequestSingle[*media_router1.Room](ctx, c.client, "CreateRoom", []string{string(nodeId)}, req, opts...)
}

func (s *roomManagerClient[NodeIdTopicType]) Close() {
	s.client.Close()
}

// ==================
// RoomManager Server
// ==================

type roomManagerServer[NodeIdTopicType ~string] struct {
	svc RoomManagerServerImpl
	rpc *server.RPCServer
}

// NewRoomManagerServer builds a RPCServer that will route requests
// to the corresponding method in the provided svc implementation.
func NewRoomManagerServer[NodeIdTopicType ~string](svc RoomManagerServerImpl, bus psrpc.MessageBus, opts ...psrpc.ServerOption) (RoomManagerServer[NodeIdTopicType], error) {
	sd := &info.ServiceDefinition{
		Name: "RoomManager",
		ID:   rand.NewServerID(),
	}

	s := server.NewRPCServer(sd, bus, opts...)

	sd.RegisterMethod("CreateRoom", false, false, true, true)
	return &roomManagerServer[NodeIdTopicType]{
		svc: svc,
		rpc: s,
	}, nil
}

func (s *roomManagerServer[NodeIdTopicType]) RegisterCreateRoomTopic(nodeId NodeIdTopicType) error {
	return server.RegisterHandler(s.rpc, "CreateRoom", []string{string(nodeId)}, s.svc.CreateRoom, nil)
}

func (s *roomManagerServer[NodeIdTopicType]) DeregisterCreateRoomTopic(nodeId NodeIdTopicType) {
	s.rpc.DeregisterHandler("CreateRoom", []string{string(nodeId)})
}

func (s *roomManagerServer[NodeIdTopicType]) allNodeTopicRegisterers() server.RegistererSlice {
	return server.RegistererSlice{
		server.NewRegisterer(s.RegisterCreateRoomTopic, s.DeregisterCreateRoomTopic),
	}
}

func (s *roomManagerServer[NodeIdTopicType]) RegisterAllNodeTopics(nodeId NodeIdTopicType) error {
	return s.allNodeTopicRegisterers().Register(nodeId)
}

func (s *roomManagerServer[NodeIdTopicType]) DeregisterAllNodeTopics(nodeId NodeIdTopicType) {
	s.allNodeTopicRegisterers().Deregister(nodeId)
}

func (s *roomManagerServer[NodeIdTopicType]) Shutdown() {
	s.rpc.Close(false)
}

func (s *roomManagerServer[NodeIdTopicType]) Kill() {
	s.rpc.Close(true)
}

var psrpcFileDescriptor8 = []byte{
	// 205 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x54, 0xce, 0xb1, 0x6a, 0xc3, 0x30,
	0x10, 0x06, 0x60, 0x4c, 0x4b, 0x0b, 0x2a, 0x85, 0x56, 0x60, 0x5a, 0x6b, 0x29, 0x74, 0x29, 0x5d,
	0x24, 0x68, 0xdf, 0xa0, 0x9d, 0xb3, 0x78, 0x0c, 0x01, 0x23, 0x4b, 0x67, 0x47, 0xc4, 0xf2, 0x29,
	0x67, 0x39, 0xef, 0x90, 0xd7, 0xc9, 0x13, 0x06, 0xd9, 0x84, 0xc4, 0x8b, 0x40, 0xff, 0x77, 0xf7,
	0x73, 0x2c, 0xa7, 0x60, 0x14, 0x21, 0x7a, 0xaf, 0x7b, 0xdd, 0x02, 0xc9, 0x40, 0x18, 0x91, 0xdf,
	0x51, 0x30, 0xe2, 0x19, 0x43, 0x74, 0xd8, 0x0f, 0x73, 0x26, 0x0a, 0x0f, 0xd6, 0xe9, 0x8a, 0x70,
	0x8c, 0x40, 0x95, 0x47, 0x0b, 0xdd, 0x85, 0xde, 0x16, 0x94, 0xea, 0x66, 0xf8, 0xd9, 0xb1, 0xa7,
	0x12, 0xd1, 0xaf, 0xe6, 0x72, 0xbe, 0x61, 0xec, 0x9f, 0x40, 0x47, 0x48, 0x21, 0xff, 0x90, 0xb7,
	0x6b, 0xf2, 0x2a, 0x25, 0xec, 0x47, 0x18, 0xa2, 0xe0, 0xcb, 0x81, 0x44, 0x9f, 0xc5, 0xe9, 0x98,
	0xe5, 0x2f, 0x99, 0x78, 0x65, 0xf7, 0x3d, 0x5a, 0xe0, 0x8f, 0xe9, 0xad, 0x9c, 0x7d, 0xcf, 0xfe,
	0xbe, 0xd7, 0x5f, 0xad, 0x8b, 0xdb, 0xb1, 0x96, 0x06, 0xbd, 0x3a, 0xb8, 0x3a, 0x12, 0x00, 0x36,
	0x8d, 0x33, 0x4e, 0x77, 0x6a, 0x3a, 0xc8, 0x60, 0xa7, 0x28, 0x98, 0xfa, 0x61, 0xfa, 0xfd, 0x9e,
	0x03, 0x00, 0x00, 0xff, 0xff, 0x31, 0x7a, 0x0c, 0x9b, 0xff, 0x00, 0x00, 0x00,
}
